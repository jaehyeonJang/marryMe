<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>소원 트리</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
      background: #000;
      color: #fff;
    }

    .track {
      width: 100%;
      height: 100vh;
      transition: transform 0.7s ease;
    }

    .page {
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      padding: 2rem;
    }

    .page h1 {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .page p {
      max-width: 800px;
      font-size: 1.2rem;
      line-height: 1.8;
      margin: 0 auto;
    }

    .page.content {
      align-items: flex-start;
      justify-content: flex-start;
      padding: 5vh 10vw;
      position: relative;
    }

    .scroll-content {
      width: 100%;
      overflow-y: auto;
      flex: 1;
      max-height: calc(100vh - 5rem); /* 제목 공간 제외 */
      padding-right: 1rem;
    }

    .scroll-content p {
      text-align: left;
      white-space: pre-wrap;
    }

    /* 인디케이터 */
    .indicator {
      position: fixed;
      top: 50%;
      right: 30px;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid #fff;
      background: transparent;
      transition: background 0.3s;
    }

    .dot.active {
      background: #fff;
    }
  </style>
</head>
<body>

  <!-- ✅ 트랙: 페이지 묶음 -->
  <div class="track">

    <!-- ✅ 1페이지: 제목 -->
    <div class="page">
      <h1>소원 트리</h1>
      <p>기억은 원래 그 사람의 것이었지만,<br>더 이상 그 사람만의 것은 아닌 세상이 되었다.</p>
    </div>

    <!-- ✅ 2페이지: 작가의 말 -->
    <div class="page">
      <h1>작가의 말</h1>
      <p>이 이야기는 잊히지 못한 사람을 향한 작은 소원입니다.<br>이 페이지를 통해 누군가의 기억이 다시 이어지길 바랍니다.</p>
    </div>

    <!-- ✅ 3페이지: 본문 + 내부 스크롤 -->
    <div class="page content">
      <h1>소설 본문</h1>
      <div class="scroll-content">
        <p>
빛과
은은한 커피 냄새가 어쩐지 낯설지 않았다.

문을 열고 들어서자, 카운터에 있던 직원이 고개를 들었다.

“안녕하세요, 이전에 이벤트 당첨되어서.. 드립세트 수형하러 왔어요”

재현은 카페 직원에게 당첨 문자를 보여주며 카페를 다시 둘러보았다.
그 순간 저 멀리 소원 트리가 재현의 시선을 끌었다.

직원은 카운터 안쪽에서 작은 상자를 꺼냈다.
"여기.. 당첨 축하드립니다!"
"저 손님..?"

재현은 상품을 건네는 직원을 뒤로한 채 소원 트리에 적힌 노란 종이를 보며
알 수 없는 그리움과 따뜻함을 느꼈다.

‘모든 것에 가장 먼저 떠오르는 사람, 건강하고 오래 행복하자 – 재현이와 가현이’

'이게.. 내가 잃어버린 기억이었구나.
사랑이었구나'
그 순간 재현은 잃어버린 기억이 사랑했던 사람이라는걸 알았다.

다시 소원 트리 앞에 선 재현은 떨리는 손이지만 망설이지 않았다.

'기억은 못 찾아도, 내가 너를 다시 찾을 거야.' -재현-

작은 쪽지를 다시 소원 트리에 걸고 나서도, 재현은 한참이나 그 자리를 떠나지 못했다.

며칠 후,
가현은 친한 동생들과 모임 후 그 카페를 다시 가게 되었다.
카페는 한가했고 커피 향은 다시 코끝을 스쳤다.

커피를 주문하고 친한 동생들은 소원 트리 앞에 서서 각자의 소원을 적었다.
가현은 재현과 적어 걸어두었던 소원을 애써 생각하지 않으며 
동생들이 어떤 소원들을 적었는지 구경하고 있었다. 

동생들이 적은 초록색 쪽지에 적힌 소원을 읽으며 웃는 그 때,
그 쪽지 옆 익숙한 글씨체가 눈에 들어왔다.

그 한 줄
'기억은 못 찾아도, 내가 너를 다시 찾을 거야. -재현-'

숨이 멎는 것 같았다.
쪽지를 다시 보고, 또 보았다.
손끝이 쪽지를 스치며, 잉크가 번질 것 처럼, 손가락이 떨렀다.

모임에서 많은 이야기들이 오갔지만 가현의 머리에는
전혀 들어오지 않았다.

잊은 줄 알았던 재현이 아직 마음속에 있음을 알았던
가현은 두근거리는 가슴을 손으로 누르며 속으로 되뇌었다.

‘그래… 나도, 다시 찾을 거야.’

카페에서 돌아온 가현은 그날 밤 내내 잠을 이루지 못했다.
재현의 그 쪽지 한줄이 자꾸 머리에 되새겨지며
다시 가현의 마음에 자리했다.

며칠 후.

가현은 방 안 깊숙이 넣어 두었던 상자를 꺼냈다.
재현과 주고받았던 편지,
함께 찍은 사진 한 장,
여행지에서 샀던 작은 기념품.

손끝에 닿는 종이와 냄새가
가현의 마음을 다시 뜨겁게 했다.

한편, 재현도 달라졌다.

쪽지를 붙인 뒤부터,
어디선가 본 듯한 장소들이
머릿속에 잔상처럼 떠올랐다.

지하철역 꽃집, 같이 갔던 한강 공원 벤치,
둘이 앉아 커피를 마시던 창가 자리.

둘은 마치 서로에게 닿으려는 듯
조금 더 일찍,
조금 더 늦게,
같은 장소를 더듬듯 찾았다.

하지만 엇갈렸다는 사실은
오히려 두 사람을 멈추지 않게 했다.

밤하늘이 밝아올 때까지,
가현은 마음속으로 계속 중얼거렸다.

‘이번엔, 내가 너를 찾아갈 거야.’

(이하 긴 본문...)
        </p>
      </div>
    </div>

    <!-- ✅ 4페이지: 맺음말 -->
    <div class="page">
      <h1>맺음말</h1>
      <p>이 이야기를 읽어주셔서 감사합니다.<br>당신의 기억에도 작은 소원이 심어지길 바랍니다.</p>
    </div>

  </div>

  <!-- ✅ 인디케이터 -->
  <div class="indicator"></div>

  <script>
    const track = document.querySelector('.track');
    const pages = document.querySelectorAll('.page');
    const indicator = document.querySelector('.indicator');
    const scrollContent = document.querySelector('.scroll-content');
    let currentPage = 0;

    // 인디케이터 dot 생성
    pages.forEach((_, i) => {
      const dot = document.createElement('div');
      dot.classList.add('dot');
      if (i === currentPage) dot.classList.add('active');
      indicator.appendChild(dot);
    });

    const dots = document.querySelectorAll('.dot');

    function updateIndicator() {
      dots.forEach((dot, i) => {
        dot.classList.toggle('active', i === currentPage);
      });
    }

    function showPage(index) {
      currentPage = Math.round(index);
      track.style.transform = `translateY(-${100 * currentPage}vh)`;
      updateIndicator();
    }

    function nextPage() {
      if (currentPage < pages.length - 1) {
        currentPage++;
        showPage(currentPage);
      }
    }

    function prevPage() {
      if (currentPage > 0) {
        currentPage--;
        showPage(currentPage);
      }
    }

    showPage(currentPage);

    let isScrolling = false;

    // PC: wheel
    window.addEventListener('wheel', e => {
      if (isScrolling) return;

      const page = pages[currentPage];
      if (page.classList.contains('content')) {
        const isAtTop = scrollContent.scrollTop === 0;
        const isAtBottom = scrollContent.scrollTop + scrollContent.clientHeight >= scrollContent.scrollHeight - 2;

        if (e.deltaY > 0 && !isAtBottom) {
          // 내부 스크롤 우선
          return;
        }
        if (e.deltaY < 0 && isAtTop) {
          isScrolling = true;
          prevPage();
          setTimeout(() => { isScrolling = false; }, 800);
          return;
        }
        if (e.deltaY > 0 && isAtBottom) {
          // allow nextPage
        } else {
          return;
        }
      }

      isScrolling = true;

      if (e.deltaY > 0) {
        nextPage();
      } else {
        prevPage();
      }

      setTimeout(() => {
        isScrolling = false;
      }, 800);
    });

    // 키보드
    window.addEventListener('keydown', e => {
      if (isScrolling) return;

      const page = pages[currentPage];
      if (page.classList.contains('content')) {
        const isAtTop = scrollContent.scrollTop === 0;
        const isAtBottom = scrollContent.scrollTop + scrollContent.clientHeight >= scrollContent.scrollHeight - 2;

        if (e.key === 'ArrowDown' && !isAtBottom) {
          return;
        }
        if (e.key === 'ArrowUp' && isAtTop) {
          isScrolling = true;
          prevPage();
          setTimeout(() => { isScrolling = false; }, 800);
          return;
        }
        if (e.key === 'ArrowDown' && isAtBottom) {
          // allow nextPage
        } else if (e.key === 'ArrowUp') {
          prevPage();
          return;
        } else {
          return;
        }
      }

      isScrolling = true;

      if (e.key === 'ArrowDown') {
        nextPage();
      } else if (e.key === 'ArrowUp') {
        prevPage();
      }

      setTimeout(() => {
        isScrolling = false;
      }, 800);
    });

    // 모바일 스와이프
    let touchStartY = 0;
    let touchEndY = 0;

    window.addEventListener('touchstart', e => {
      touchStartY = e.changedTouches[0].screenY;
    }, false);

    window.addEventListener('touchend', e => {
      touchEndY = e.changedTouches[0].screenY;
      handleGesture();
    }, false);

    function handleGesture() {
      if (isScrolling) return;

      const page = pages[currentPage];
      if (page.classList.contains('content')) {
        const isAtTop = scrollContent.scrollTop === 0;
        const isAtBottom = scrollContent.scrollTop + scrollContent.clientHeight >= scrollContent.scrollHeight - 2;

        if (touchStartY - touchEndY > 50 && !isAtBottom) {
          return;
        }
        if (touchEndY - touchStartY > 50 && isAtTop) {
          isScrolling = true;
          prevPage();
          setTimeout(() => { isScrolling = false; }, 800);
          return;
        }
        if (touchStartY - touchEndY > 50 && isAtBottom) {
          // allow nextPage
        } else {
          return;
        }
      }

      isScrolling = true;

      if (touchStartY - touchEndY > 50) {
        nextPage();
      } else if (touchEndY - touchStartY > 50) {
        prevPage();
      }

      setTimeout(() => {
        isScrolling = false;
      }, 800);
    }
  </script>
</body>
</html>
